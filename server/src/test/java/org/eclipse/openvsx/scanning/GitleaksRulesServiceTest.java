/********************************************************************************
 * Copyright (c) 2025 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * https://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/
package org.eclipse.openvsx.scanning;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for {@link GitleaksRulesService}.
 * <p>
 * These tests verify configuration validation, path resolution, and file generation logic
 * without requiring network access or actual rule generation.
 */
class GitleaksRulesServiceTest {

    @TempDir
    Path tempDir;

    @Test
    void skipsGenerationWhenDisabled() {
        SecretDetectorConfig config = buildConfig(false, false, null);
        // Create service without detectorFactory (we're testing initialization, not refresh)
        GitleaksRulesService service = new GitleaksRulesService(config, null, null);

        // When auto-fetch is disabled, initialize() should skip generation
        // Service is created but does nothing since auto-fetch is disabled
        assertNull(service.getGeneratedRulesPath(), "Path should not be set when disabled");
    }

    @Test
    void skipsGenerationWhenAutoGenerateDisabled() {
        SecretDetectorConfig config = buildConfig(true, false, tempDir.resolve("rules.yaml").toString());
        GitleaksRulesService service = new GitleaksRulesService(config, null, null);

        // Service should not set generated path when auto-generate is disabled
        assertNull(service.getGeneratedRulesPath(), "Path should not be set when auto-generate is disabled");
    }

    @Test
    void failsWhenAutoGenerateEnabledButPathNotConfigured() {
        SecretDetectorConfig config = buildConfig(true, true, "");  // Empty path
        GitleaksRulesService service = new GitleaksRulesService(config, null, null);

        IllegalStateException exception = assertThrows(
            IllegalStateException.class,
            service::initialize,
            "Should throw when path is not configured"
        );

        // Check the cause since resolveOutputFile exceptions are wrapped
        Throwable cause = exception.getCause();
        assertNotNull(cause, "Should have a cause");
        assertTrue(cause.getMessage().contains("gitleaks.output-path") || cause.getMessage().contains("not configured"),
            "Error message should mention the missing configuration property");
    }

    @Test
    void failsWhenAutoGenerateEnabledButPathIsNull() {
        SecretDetectorConfig config = buildConfig(true, true, null);  // Null path
        GitleaksRulesService service = new GitleaksRulesService(config, null, null);

        IllegalStateException exception = assertThrows(
            IllegalStateException.class,
            service::initialize,
            "Should throw when path is null"
        );

        // Check the cause since resolveOutputFile exceptions are wrapped
        Throwable cause = exception.getCause();
        assertNotNull(cause, "Should have a cause");
        assertTrue(cause.getMessage().contains("not configured"));
    }

    @Test
    void createsParentDirectoryIfNotExists() throws Exception {
        Path outputFile = tempDir.resolve("subdir1/subdir2/rules.yaml");
        assertFalse(Files.exists(outputFile.getParent()), "Parent directory should not exist yet");

        SecretDetectorConfig config = buildConfig(true, true, outputFile.toString());
        GitleaksRulesService service = new GitleaksRulesService(config, null, null);

        // Call resolveOutputFile via reflection
        Method resolveMethod = GitleaksRulesService.class.getDeclaredMethod("resolveOutputFile");
        resolveMethod.setAccessible(true);
        File result = (File) resolveMethod.invoke(service);

        assertNotNull(result);
        assertTrue(Files.exists(result.getParentFile().toPath()), 
            "Parent directory should be created");
        assertEquals(outputFile.toString(), result.getAbsolutePath());
    }

    @Test
    void failsWhenParentDirectoryCannotBeCreated() throws Exception {
        // Create a directory structure where the parent doesn't exist yet
        // and make it impossible to create by having a file in the way
        Path subDir = tempDir.resolve("subdir");
        
        // First create the subdir as a file (not a directory)
        Files.writeString(subDir, "content");
        
        // Now try to create a file under it - this should fail
        Path impossiblePath = tempDir.resolve("subdir/content/rules.yaml");

        SecretDetectorConfig config = buildConfig(true, true, impossiblePath.toString());
        GitleaksRulesService service = new GitleaksRulesService(config, null, null);

        IllegalStateException exception = assertThrows(
            IllegalStateException.class,
            service::initialize
        );

        // The error will be wrapped, check the cause
        Throwable cause = exception.getCause();
        assertNotNull(cause, "Should have a cause");
        assertTrue(cause.getMessage().contains("Cannot create directory") ||
                   cause.getMessage().contains("Cannot write to directory"),
            "Error message should mention directory issue: " + cause.getMessage());
    }

    @Test
    void skipsGenerationWhenFileExistsAndNoForceRegenerate() throws Exception {
        Path outputFile = tempDir.resolve("existing-rules.yaml");
        Files.writeString(outputFile, "existing content");
        long originalSize = Files.size(outputFile);

        SecretDetectorConfig config = buildConfig(true, true, outputFile.toString());
        setField(config, "gitleaksForceRefresh", false);
        GitleaksRulesService service = new GitleaksRulesService(config, null, null);

        service.initialize();

        // File should not be modified
        assertEquals(originalSize, Files.size(outputFile), "File should not be regenerated");
        assertEquals("existing content", Files.readString(outputFile), "Content should be unchanged");
        
        // Path should still be set
        assertEquals(outputFile.toAbsolutePath().toString(), service.getGeneratedRulesPath());
    }

    @Test
    void storesGeneratedPathForLaterRetrieval() throws Exception {
        Path outputFile = tempDir.resolve("rules.yaml");
        Files.writeString(outputFile, "test");  // Pre-create to skip actual generation

        SecretDetectorConfig config = buildConfig(true, true, outputFile.toString());
        setField(config, "gitleaksForceRefresh", false);
        GitleaksRulesService service = new GitleaksRulesService(config, null, null);

        assertNull(service.getGeneratedRulesPath(), "Path should be null before generation");

        service.initialize();

        assertNotNull(service.getGeneratedRulesPath(), "Path should be set after generation");
        assertEquals(outputFile.toAbsolutePath().toString(), service.getGeneratedRulesPath());
    }

    @Test
    void resolveOutputFileReturnsNullWhenPathNotConfigured() throws Exception {
        SecretDetectorConfig config = buildConfig(true, true, "");
        GitleaksRulesService service = new GitleaksRulesService(config, null, null);

        Method resolveMethod = GitleaksRulesService.class.getDeclaredMethod("resolveOutputFile");
        resolveMethod.setAccessible(true);

        // Should throw when trying to resolve (wrapped in InvocationTargetException due to reflection)
        Exception exception = assertThrows(Exception.class, () -> {
            resolveMethod.invoke(service);
        });
        
        // Unwrap the InvocationTargetException
        Throwable cause = exception.getCause();
        assertInstanceOf(IllegalStateException.class, cause, "Cause should be IllegalStateException");
        assertTrue(cause.getMessage().contains("not configured"),
            "Error message should explain the configuration is missing");
    }

    @Test
    void acceptsAbsolutePath() throws Exception {
        Path outputFile = tempDir.resolve("absolute-path-rules.yaml").toAbsolutePath();

        SecretDetectorConfig config = buildConfig(true, true, outputFile.toString());
        GitleaksRulesService service = new GitleaksRulesService(config, null, null);

        Method resolveMethod = GitleaksRulesService.class.getDeclaredMethod("resolveOutputFile");
        resolveMethod.setAccessible(true);
        File result = (File) resolveMethod.invoke(service);

        assertEquals(outputFile.toString(), result.getAbsolutePath());
    }

    @Test
    void acceptsRelativePath() throws Exception {
        String relativePath = "relative/path/rules.yaml";

        SecretDetectorConfig config = buildConfig(true, true, relativePath);
        GitleaksRulesService service = new GitleaksRulesService(config, null, null);

        Method resolveMethod = GitleaksRulesService.class.getDeclaredMethod("resolveOutputFile");
        resolveMethod.setAccessible(true);
        File result = (File) resolveMethod.invoke(service);

        assertNotNull(result);
        assertTrue(result.getPath().contains("relative"));
    }

    // Helper methods

    private SecretDetectorConfig buildConfig(boolean enabled, boolean autoGenerate, String path) {
        SecretDetectorConfig config = new SecretDetectorConfig();
        try {
            setField(config, "enabled", enabled);
            setField(config, "gitleaksAutoFetch", autoGenerate);
            setField(config, "gitleaksOutputPath", path);
            setField(config, "gitleaksForceRefresh", false);
            setField(config, "rulesPath", "classpath:test-rules.yaml");
        } catch (Exception e) {
            throw new RuntimeException("Failed to configure test config", e);
        }
        return config;
    }

    private void setField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}

